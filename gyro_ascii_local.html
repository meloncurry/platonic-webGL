<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Gyro ASCII Fullscreen Centered - Fixed Scale & Pivot</title>
<style>
  :root { --bg: #000; --fg: #bfefff; --err: #ff4444; }
  html, body {
    margin: 0; padding: 0; height: 100%;
    background: var(--bg);
    color: var(--fg);
    font-family: monospace;
    overflow: hidden;
  }
  #links {
    position: fixed;
    top: 12px;
    left: 12px;
    z-index: 50;
    font-size: 14px;
  }
  #links a {
    color: var(--fg);
    text-decoration: underline;
    display: block;
    margin-bottom: 6px;
  }
  pre#ascii {
    position: fixed;
    top: 0; left: 0; width: 100vw; height: 100vh;
    margin: 0; padding: 12px 14px;
    background: var(--bg);
    color: var(--fg);
    white-space: pre;
    font-size: 7px;
    line-height: 6.5px;
    letter-spacing: 0.5px;
    overflow: hidden;
    pointer-events: none;
    user-select: none;
    image-rendering: pixelated;
    z-index: 10;
  }
  #loading {
    position: fixed;
    left: 50%; top: 44%;
    transform: translate(-50%, -50%);
    z-index: 60;
    color: var(--fg);
    text-align: center;
    white-space: pre;
    font-size: 14px;
    background: rgba(0, 0, 0, 0.4);
    padding: 10px 14px;
    border-radius: 8px;
  }
  #error {
    position: fixed;
    left: 50%; top: 50%;
    transform: translate(-50%, -50%);
    z-index: 80;
    color: var(--err);
    background: rgba(0, 0, 0, 0.9);
    padding: 12px;
    min-width: 60vw;
    max-width: 90vw;
    white-space: pre-wrap;
    font-size: 13px;
    border-radius: 8px;
    display: none;
    box-shadow: 0 0 20px rgba(255, 0, 0, 0.15);
  }
  #debug {
    position: fixed;
    left: 12px;
    bottom: 12px;
    z-index: 30;
    color: #999;
    font-size: 11px;
    white-space: pre-line;
  }
  canvas {
    display: none; /* Hide the WebGL canvas */
  }
</style>
</head>
<body>
  <div id="links">
    <a href="#">Home</a>
    <a href="#">About</a>
    <a href="#">Contact</a>
  </div>

  <div id="loading">Booting renderer...\n[                    ] 0%</div>
  <div id="error"></div>
  <pre id="ascii">Initializingâ€¦</pre>
  <div id="debug">Debug logs will appear here.</div>

  <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
  <script>
  (function(){
    const loadingEl = document.getElementById('loading');
    const asciiPre = document.getElementById('ascii');
    const errorEl = document.getElementById('error');
    const debugEl = document.getElementById('debug');

    function showError(msg){
      console.error(msg);
      errorEl.style.display = 'block';
      errorEl.textContent = 'ERROR:\n\n' + msg;
      asciiPre.textContent = '';
    }

    window.addEventListener('error', (ev) => {
      const m = (ev && ev.error && ev.error.stack) ? ev.error.stack : (ev.message || String(ev));
      showError(m);
    });
    window.addEventListener('unhandledrejection', ev => {
      showError('Unhandled Promise Rejection:\n' + (ev.reason && ev.reason.stack ? ev.reason.stack : String(ev.reason)));
    });

    let ASCII_COLS = 120;
    let ASCII_ROWS = 48;
    const ASCII_CHARS = " .'`^\",:;Il!i~+_-?][}{1)(|\\/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$";

    let renderer, scene, camera, rt, pixelBuffer;
    let dodeWire, cubeWire, tetraWire, cubePivot, tetraPivot;
    let raycaster, mouseNDC, plane;
    let v0_local;

    let dodeSize, cubeSize, tetraSize, scaleFactor;

    function updateScaleAndPosition(){
      const width = window.innerWidth;
      const height = window.innerHeight;
      const aspect = width / height;

      renderer.setSize(width, height);
      rt.setSize(ASCII_COLS, ASCII_ROWS);

      camera.aspect = aspect;
      camera.updateProjectionMatrix();

      const cameraZ = camera.position.z; // 20 fixed
      const fovRadians = THREE.MathUtils.degToRad(camera.fov);
      const visibleHeight = 2 * Math.tan(fovRadians / 2) * cameraZ;
      const visibleWidth = visibleHeight * aspect;

      const baseSize = 6.0; // dodecahedron base size units

      const maxModelHeight = visibleHeight * 0.8;
      const maxModelWidth = visibleWidth * 0.8;

      const scaleY = maxModelHeight / baseSize;
      const scaleX = maxModelWidth / baseSize;

      scaleFactor = Math.min(scaleX, scaleY);

      scaleFactor = Math.min(Math.max(scaleFactor, 0.5), 4);

      dodeSize = baseSize * scaleFactor;
      cubeSize = 3.0 * scaleFactor;
      tetraSize = 1.3 * scaleFactor;

      // Position tetrahedron away from cube center along +Z so axis vector is nonzero
      if (tetraPivot){
        tetraPivot.position.set(0, 0, cubeSize / 2 + tetraSize / 2);
      }
    }

    try {
      renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: false });
      document.body.appendChild(renderer.domElement);

      rt = new THREE.WebGLRenderTarget(ASCII_COLS, ASCII_ROWS, {
        minFilter: THREE.NearestFilter,
        magFilter: THREE.NearestFilter,
        format: THREE.RGBAFormat,
      });

      pixelBuffer = new Uint8Array(ASCII_COLS * ASCII_ROWS * 4);

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      camera = new THREE.PerspectiveCamera(45, ASCII_COLS / ASCII_ROWS, 0.1, 1000);
      camera.position.set(0, 0, 20);
      camera.lookAt(0, 0, 0);

      scene.add(new THREE.AmbientLight(0xffffff, 0.6));
      const dir = new THREE.DirectionalLight(0xffffff, 0.4);
      dir.position.set(5, 5, 5);
      scene.add(dir);

      updateScaleAndPosition();

      const matT = new THREE.LineBasicMaterial({ color: 0xbfefff });
      const matC = new THREE.LineBasicMaterial({ color: 0xffc0ea });
      const matD = new THREE.LineBasicMaterial({ color: 0xd7ffb3 });

      const tetraGeom = new THREE.TetrahedronGeometry(tetraSize);
      v0_local = new THREE.Vector3().fromBufferAttribute(tetraGeom.attributes.position, 0).clone();
      const tetraEdges = new THREE.EdgesGeometry(tetraGeom);
      tetraWire = new THREE.LineSegments(tetraEdges, matT);

      const cubeEdges = new THREE.EdgesGeometry(new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize));
      cubeWire = new THREE.LineSegments(cubeEdges, matC);

      const dodeEdges = new THREE.EdgesGeometry(new THREE.DodecahedronGeometry(dodeSize));
      dodeWire = new THREE.LineSegments(dodeEdges, matD);

      const root = new THREE.Object3D();
      root.position.set(0, 0, 0);
      scene.add(root);

      const dodeGroup = new THREE.Object3D();
      root.add(dodeGroup);
      dodeGroup.add(dodeWire);

      cubePivot = new THREE.Object3D();
      dodeGroup.add(cubePivot);
      cubePivot.add(cubeWire);

      tetraPivot = new THREE.Object3D();
      cubePivot.add(tetraPivot);
      tetraPivot.add(tetraWire);

      // Now position tetraPivot away along +Z
      tetraPivot.position.set(0, 0, cubeSize / 2 + tetraSize / 2);

      raycaster = new THREE.Raycaster();
      mouseNDC = new THREE.Vector2(0, 0);
      plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), -3.5);

      window.addEventListener('mousemove', (ev) => {
        mouseNDC.x = (ev.clientX / window.innerWidth) * 2 - 1;
        mouseNDC.y = -((ev.clientY / window.innerHeight) * 2 - 1);
      });

      window.addEventListener('resize', () => {
        updateScaleAndPosition();
      });

      debugEl.style.display = 'block';
      debugEl.textContent = `Render target: ${ASCII_COLS}x${ASCII_ROWS}\nScale factor: ${scaleFactor.toFixed(3)}`;
    } catch (e) {
      showError('Initialization error:\n' + (e && e.stack ? e.stack : String(e)));
      return;
    }

    function ndcToWorldOnPlane(ndc, plane) {
      raycaster.setFromCamera(ndc, camera);
      const out = new THREE.Vector3();
      if (raycaster.ray.intersectPlane(plane, out)) return out;
      return null;
    }

    function aimTetraAt(targetWorld) {
      if (!targetWorld) return;
      const tetraWorldPos = new THREE.Vector3();
      tetraPivot.getWorldPosition(tetraWorldPos);

      const targetDir = new THREE.Vector3().subVectors(targetWorld, tetraWorldPos).normalize();
      if (targetDir.lengthSq() < 1e-8) return;

      const parentWorldQ = new THREE.Quaternion();
      tetraWire.getWorldQuaternion(parentWorldQ);
      const v0_world = v0_local.clone().applyQuaternion(parentWorldQ).normalize();

      const q = new THREE.Quaternion().setFromUnitVectors(v0_world, targetDir);
      const newWorldQ = q.multiply(parentWorldQ);

      const parentQinv = new THREE.Quaternion();
      if (tetraWire.parent) tetraWire.parent.getWorldQuaternion(parentQinv).invert();
      else parentQinv.identity();
      const localQ = newWorldQ.clone().premultiply(parentQinv);

      tetraWire.quaternion.slerp(localQ, 0.35);
    }

    function updateCubeGyro(dt) {
      const cubeWorldPos = new THREE.Vector3();
      cubePivot.getWorldPosition(cubeWorldPos);
      const tetraWorldPos = new THREE.Vector3();
      tetraPivot.getWorldPosition(tetraWorldPos);

      const axisCT = new THREE.Vector3().subVectors(tetraWorldPos, cubeWorldPos);
      debugEl.textContent = `Render target: ${ASCII_COLS}x${ASCII_ROWS}\nScale factor: ${scaleFactor.toFixed(3)}\n\n` +
        `axisCT length: ${axisCT.length().toFixed(6)}`;

      if (axisCT.lengthSq() < 1e-8) return;

      axisCT.normalize();

      const arbitrary = Math.abs(axisCT.dot(new THREE.Vector3(0, 1, 0))) < 0.9 ? new THREE.Vector3(0, 1, 0) : new THREE.Vector3(1, 0, 0);
      const perp = new THREE.Vector3().crossVectors(axisCT, arbitrary).normalize();

      const z = axisCT.clone();
      const y = perp.clone();
      const x = new THREE.Vector3().crossVectors(y, z).normalize();
      const m = new THREE.Matrix4(); m.makeBasis(x, y, z);
      const desiredQ = new THREE.Quaternion().setFromRotationMatrix(m);

      const stabilityQ = new THREE.Quaternion();
      if (dodeWire.parent) dodeWire.parent.getWorldQuaternion(stabilityQ);
      else stabilityQ.identity();

      const finalQ = new THREE.Quaternion();
      finalQ.copy(stabilityQ).slerp(desiredQ, 0.6);

      const parentWorldQInv = new THREE.Quaternion();
      if (cubePivot.parent) cubePivot.parent.getWorldQuaternion(parentWorldQInv).invert();
      else parentWorldQInv.identity();
      const localFinal = finalQ.clone().premultiply(parentWorldQInv);

      debugEl.textContent +=
        `\ncubePivot quaternion before: [${cubePivot.quaternion.toArray().map(n => n.toFixed(3)).join(', ')}]`;

      cubePivot.quaternion.slerp(localFinal, 0.2 + Math.min(0.5, dt * 0.001));

      debugEl.textContent +=
        `\ncubePivot quaternion after:  [${cubePivot.quaternion.toArray().map(n => n.toFixed(3)).join(', ')}]`;
    }

    function pixelsToASCII(buffer, cols, rows) {
      let out = '';
      for (let y = 0; y < rows; y++) {
        const readY = rows - 1 - y;
        for (let x = 0; x < cols; x++) {
          const idx = (readY * cols + x) * 4;
          const r = buffer[idx], g = buffer[idx + 1], b = buffer[idx + 2];
          const lum = 0.2126 * r + 0.7152 * g + 0.0722 * b;
          const norm = lum / 255;
          const charIndex = Math.floor(norm * (ASCII_CHARS.length - 1));
          out += ASCII_CHARS.charAt(charIndex);
        }
        out += '\n';
      }
      return out;
    }

    let lastTime = performance.now();
    let asciiLast = 0;
    let framesRendered = 0;
    const asciiInterval = 50;

    function animate(time){
      try {
        const dt = time - lastTime;
        lastTime = time;

        const targetWorld = ndcToWorldOnPlane(mouseNDC, plane);

        aimTetraAt(targetWorld);
        updateCubeGyro(dt);

        renderer.setRenderTarget(rt);
        renderer.render(scene, camera);
        renderer.setRenderTarget(null);

        if (time - asciiLast > asciiInterval) {
          asciiLast = time;
          renderer.readRenderTargetPixels(rt, 0, 0, ASCII_COLS, ASCII_ROWS, pixelBuffer);
          const ascii = pixelsToASCII(pixelBuffer, ASCII_COLS, ASCII_ROWS);
          asciiPre.textContent = ascii;
        }

        framesRendered++;
        if (framesRendered === 3) {
          loadingEl.style.display = 'none';
        }

        requestAnimationFrame(animate);
      } catch (err) {
        showError('Runtime error in render loop:\n' + (err && err.stack ? err.stack : String(err)));
      }
    }

    setTimeout(() => requestAnimationFrame(animate), 120);

    let prog = 0;
    const progT = setInterval(() => {
      prog = Math.min(100, prog + (framesRendered > 0 ? 40 : 6));
      loadingEl.textContent = 'Booting renderer...\n[' + '#'.repeat(Math.round(prog/100*20)) + ' '.repeat(20 - Math.round(prog/100*20)) + `] ${prog}%`;
      if (prog >= 100 || framesRendered > 0) {
        loadingEl.textContent = 'Booting renderer...\n[' + '#'.repeat(20) + `] 100%`;
        if (framesRendered > 0) {
          setTimeout(() => { loadingEl.style.display = 'none'; }, 220);
        }
        clearInterval(progT);
      }
    }, 80);

    window._gyro_debug = {
      renderer, rt, pixelBuffer, ASCII_COLS, ASCII_ROWS
    };
  })();
  </script>
</body>
</html>
